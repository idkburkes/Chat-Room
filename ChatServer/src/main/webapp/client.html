<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Chat Application</title>
</head>

  <style>
  
  body {
    background: grey;
    margin: 0;
  overflow: hidden;
  }
  
  #game {
  	background-color: blue;
  	width: 50%;
  	height: 50%;
  }
  </style>
  

<body>


<textarea id="echoText" rows="5" cols="20"></textarea>

<canvas id="game"> </canvas>



<script>
var webSocket = new WebSocket("ws://localhost:8080/ChatServer/chat");

//Functions
webSocket.onopen = function(message){ wsOpen(message);};
webSocket.onmessage = function(message){ wsGetMessage(message);};
webSocket.onclose = function(message){ wsClose(message);};
webSocket.onerror = function(event){ wsError(event);};

//open
function wsOpen(message){
    echoText.value += "---- Welcome to Pong! ----- \n";
}

//Send message
function wsSendMessage(){
	
}

//Close
function wsCloseConnection(){
    webSocket.close();
}

//Message Received 
function wsGetMessage(event){
	
    //Handle Left Paddle Events
    if(event.data === 's') {
    	paddle.y += paddleSpeed;
    } else if(event.data === 'w') {
    	paddle.y -= paddleSpeed;
    } else if(event.data === 'a') {
    	 paddle.x -= paddleSpeed;
    } else if(event.data === 'd') {
    	paddle.x += paddleSpeed;
    }
    
    //Handle Right Paddle Events
     if(event.data === 'down') {
    	paddle2.y += 3;
    } else if(event.data === 'up') {
    	paddle2.y -= 3;
    } else if(event.data === 'left') {
    	 paddle2.x -= 3;	
    } else if(event.data === 'right') {
    	paddle2.x += 3;
    }
}

//Connection Closed
function wsClose(message){
    echoText.value += "Disconnect ... \n";
}

//Error
function wsError(message){
    echoText.value += "Error...   \n";
}


//2D Game Component 
const canvas = document.getElementById('game');
const context = canvas.getContext('2d');

var grid = 10;
var paddleSpeed = 3;
var ballSpeed = 2;
var paddleHeight = 40;
const maxPaddleY = canvas.height - grid - paddleHeight;

const paddle = {
		x: grid,
		y: canvas.height / 2,
		height: paddleHeight,
		width: 10
};


const paddle2 = {
		x: canvas.width - (grid * 2),
		y: canvas.height / 2,
		height: paddleHeight,
		width: 10
}

const ball = {
		x: canvas.width / 2,
		y: canvas.height / 2,
		height: 90,
		width: 90,
		visualSmallRadius: 2,
		visualBigRadius: 8,
		// ball velocity (start going to the top-right corner)
		dx: ballSpeed,
		dy: -ballSpeed
}


//check for collision between two objects using axis-aligned bounding box (AABB)
//@see https://developer.mozilla.org/en-US/docs/Games/Techniques/2D_collision_detection
function collides(obj1, obj2) {
return obj1.x < obj2.x + obj2.width &&
      obj1.x + (obj1.width - 70) > obj2.x &&
      obj1.y < obj2.y + obj2.height &&
      obj1.y + (obj1.height - 60) > obj2.y;
}


//Event Listeners
document.addEventListener('keydown', handleKeyPress);

function handleKeyPress(e) {
	switch(e.which) {
	 case 37: // right paddle left
	 	webSocket.send('left');
	 	break;

	 case 38: // right paddle up
     	webSocket.send('up');
	 	break;

	 case 39: // right paddle right
	 	webSocket.send('right');
	 	break;

	 case 40: // right paddle down
		 webSocket.send('down');
	 	break;
	 
	 case 87:
	 	webSocket.send('w');
	 	break;
	 
	 case 65:
		 webSocket.send('a');
		 break;
 
	 case 83:
		 webSocket.send('s');
		 break;
		 
	 case 68:
		 webSocket.send('d');
		 break;

	 default: return; // exit this handler for other keys
	}
}



//Game Loop
function loop() {
	window.requestAnimationFrame(loop); //Request frame update
	context.clearRect(0,0,canvas.width,canvas.height); //Erase previous animation
	 
	
	// move ball by its velocity
	  ball.x += ball.dx;
	  ball.y += ball.dy;
	  
	// prevent paddles from going through walls
	  if (paddle.y < grid) {
	    paddle.y = grid;
	  }
	  else if (paddle.y > maxPaddleY) {
	    paddle.y = maxPaddleY;
	  }

	  if (paddle2.y < grid) {
	    paddle2.y = grid;
	  }
	  else if (paddle2.y > maxPaddleY) {
	    paddle2.y = maxPaddleY;
	  }
	
	// prevent ball from going through walls by changing its velocity
	  if (ball.y < grid) {
	    ball.y = grid;
	    ball.dy *= -1;
	  }
	  else if (ball.y + grid > canvas.height - grid) {
	    ball.y = canvas.height - grid * 2;
	    ball.dy *= -1;
	  }
	
	
	  // check to see if ball collides with paddle. if they do change x velocity
	  if (collides(ball, paddle)) {
	    ball.dx *= -1;

	    // move ball next to the paddle otherwise the collision will happen again
	    // in the next frame
	    ball.x = paddle.x + paddle.width;
	  }
	  else if (collides(ball, paddle2)) {
	    ball.dx *= -1;

	    // move ball next to the paddle otherwise the collision will happen again
	    // in the next frame
	    ball.x = paddle2.x - ball.width;
	  }

	
	
	//Draw Paddles
	context.fillStyle = 'black';
	context.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
	context.fillRect(paddle2.x, paddle2.y, paddle2.width, paddle2.height);
	
	
	  // Create gradients
	  var radgrad = context.createRadialGradient(ball.x + 30, ball.y + 20, ball.visualSmallRadius, ball.x + 30, ball.y + 25, ball.visualBigRadius);
	  context.fillStyle = radgrad;
	  radgrad.addColorStop(0, '#A7D30C');
	  radgrad.addColorStop(0.9, '#019F62');
	  radgrad.addColorStop(1, 'rgba(1, 159, 98, 0)');
	  //Draw Ball
	  context.fillRect(ball.x - 50, ball.y - 50, ball.width, ball.height);
	
	  // draw walls
	  context.fillStyle = 'lightgrey';
	  context.fillRect(0, 0, canvas.width, grid);
	  context.fillRect(0, canvas.height - grid, canvas.width, canvas.height);
}

//Start the game
window.requestAnimationFrame(loop);







</script>










</body>




</html>